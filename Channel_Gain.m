function channel_loss = Channel_Gain( channel, ...
                                      distance3d, ...
                                      blockedAps, ...
                                      ueHolding, ...
                                      isReflecting, ...
                                      bodyAttenuation_vector )
% CHANNEL LOSS MODELS
%
% INPUTS:
%   channel - <struct> structure with channel parameters and functions
%   model - <string> the name of the model
%   distance3d - <double 1xN> Euclidean distances from the APs to the UE
%   blockedAps - <boolean 1xN> APs that have direct link to UE blocked
%   ueHolding - <boolean> indicates that UE is either in pocket or on hand
%                                  
% OUTPUTS:
%   channel_loss - <double 1xN> the attenuation given by the channel

switch channel.model
    case 'yoo2017fading_hallway'
        channel_loss = ...
            (1-blockedAps) .* ( ... % line-of-sight
        channel.PL( distance3d, channel.p0_dB(1,ueHolding), channel.n(1,ueHolding) ) .* ...
        channel.SMALL_FADING_POWER_GAIN( 1, ueHolding, size(distance3d) ) ) + ...
            blockedAps .* (... % non-line-of-sight
        channel.PL( distance3d, channel.p0_dB(2,ueHolding), channel.n(2,ueHolding) ) .* ...
        channel.SMALL_FADING_POWER_GAIN(  2, ueHolding, size(distance3d) )  .* ...
        bodyAttenuation_vector(1) );
    case 'yoo2017measurements'
        channel.channel_loss = ...
            (1-blockedAps) .* ( ... % line-of-sight
        channel.PL( distance3d, channel.p0_dB(1,ueHolding), channel.n(1,ueHolding) ) .* ...
        channel.SHADOWING_FADING_POWER_GAIN( 1, ueHolding, size(distance3d) ) .* ...
        channel.SMALL_FADING_POWER_GAIN( 1, ueHolding, size(distance3d) ) ) + ...
            blockedAps .* (... % non-line-of-sight
        channel.PL( distance3d, channel.p0_dB(2,ueHolding), channel.n(2,ueHolding) ) .* ...
        channel.SHADOWING_FADING_POWER_GAIN( 2, ueHolding, size(distance3d) ) .* ...
        channel.SMALL_FADING_POWER_GAIN(  2, ueHolding, size(distance3d) ) );
    case 'userOrientedFading_2'
        channel_loss = ...
            (1-blockedAps) .* ( ... % line-of-sight
        channel.PL( distance3d, channel.p0_dB(1,ueHolding), channel.n(1,ueHolding) ) ) + ...
            blockedAps .* (... % non-line-of-sight
        channel.PL( distance3d, channel.p0_dB(2,ueHolding), channel.n(2,ueHolding) ) .* ...
        bodyAttenuation_vector(1) );
        channel_loss = channel_loss .* ( ...
            isReflecting .* ...
        random( channel.FADING_REFLECTED, size(isReflecting) ).^2 + ...
            (1 - isReflecting) .* ...
        random( channel.FADING_DIRECT, size(isReflecting) ).^2 );
%     case 'userOrientedFading_3'
%         % Nakagami m parameter varies linearly with the body orientation angle
%         angles = pi .* rand(1,length(rxPower));
%         channel_loss = ... % angles is uniformly distributed in [0,pi]
%     (angles < pi/4) .* random( FADING_REFLECTED, size(angles) ).^2 + ...
%     (1 - angles < pi/3) .* ( ...
%         (angles < 2*pi/3) .* random( FADING_SCATTERED, size(angles) ).^2 + ...
%         ( 1 - angles < 2*pi/3) .* random( FADING_DIRECT, size(angles) ).^2 );
    otherwise
        channel_loss = ...
            (1-blockedAps) .* ( ... % line-of-sight
        channel.PL( distance3d, channel.p0_dB(1,ueHolding), channel.n(1,ueHolding) ) ) + ...
            blockedAps .* (... % non-line-of-sight
        channel.PL( distance3d, channel.p0_dB(2,ueHolding), channel.n(2,ueHolding) ) .* ...
        bodyAttenuation_vector(1) );

end

end